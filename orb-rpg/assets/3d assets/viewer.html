<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OrbRPG 3D Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * { margin: 0; padding: 0; }
        body {
            width: 100vw;
            height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }
        canvas { flex: 1; display: block; }
        #controls {
            background: #1a1a1a;
            color: #fff;
            padding: 15px;
            border-top: 1px solid #666;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        input[type="file"] {
            padding: 8px;
            background: #333;
            border: 1px solid #666;
            color: #fff;
            cursor: pointer;
            flex: 1;
        }
        #status {
            padding: 8px 15px;
            background: #2a2a2a;
            border-radius: 4px;
            font-size: 12px;
            min-width: 250px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <input type="file" id="fileInput" accept=".glb,.gltf" placeholder="Select GLB file">
        <div id="status">Ready - select a model</div>
    </div>

    <script>
        console.log('=== 3D Viewer Starting ===');
        
        let scene, camera, renderer, model;
        let isInitialized = false;

        function initScene() {
            if (isInitialized) return;
            
            console.log('Initializing Three.js scene');
            
            const canvas = document.getElementById('canvas');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (model) {
                    model.rotation.y += 0.005;
                }
                renderer.render(scene, camera);
            }
            animate();

            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    scene.rotation.y += deltaX * 0.01;
                    scene.rotation.x += deltaY * 0.01;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Zoom with scroll
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.001;
                camera.position.z = Math.max(0.5, Math.min(20, camera.position.z));
            });

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            isInitialized = true;
            console.log('✓ Scene initialized');
        }

        function loadModel(file) {
            if (!isInitialized) {
                initScene();
            }

            console.log('Loading file:', file.name);
            document.getElementById('status').textContent = `Loading: ${file.name}...`;

            const url = URL.createObjectURL(file);
            const loader = new THREE.GLTFLoader();

            loader.load(
                url,
                (gltf) => {
                    console.log('✓ Model loaded!');
                    
                    if (model) {
                        scene.remove(model);
                    }
                    
                    model = gltf.scene;
                    scene.add(model);

                    // Auto-fit camera
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    model.position.sub(center);
                    
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    model.scale.multiplyScalar(scale);

                    // Count meshes
                    let meshCount = 0;
                    model.traverse((child) => {
                        if (child.isMesh) meshCount++;
                    });

                    document.getElementById('status').textContent = `✓ ${file.name} (${meshCount} meshes)`;
                    console.log('Loaded:', meshCount, 'meshes');
                },
                (progress) => {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    console.log('Progress:', percent + '%');
                },
                (error) => {
                    console.error('✗ Load error:', error);
                    document.getElementById('status').textContent = `✗ Error: ${error.message}`;
                }
            );
        }

        // File input
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadModel(e.target.files[0]);
            }
        });

        // Drag & drop
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer.files.length > 0) {
                loadModel(e.dataTransfer.files[0]);
            }
        });

        // Initialize on page load
        window.addEventListener('load', () => {
            console.log('Page loaded, checking Three.js...');
            console.log('THREE available?', typeof THREE);
            initScene();
        });

        console.log('=== Viewer Ready ===');
    </script>
</body>
</html>
