<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Orb RPG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #1a1a1a; 
            color: #fff;
            overflow: hidden;
        }
        #canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            max-width: 300px;
        }
        #status {
            color: #4f4;
            margin-bottom: 10px;
            font-weight: bold;
        }
        #status.error { color: #f44; }
        input[type="file"] {
            margin: 10px 0;
            display: block;
            cursor: pointer;
        }
        .info {
            color: #aaa;
            font-size: 11px;
            line-height: 1.6;
            margin-top: 10px;
        }
        #canvas { cursor: grab; }
        #canvas:active { cursor: grabbing; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div id="status">âœ“ Viewer Ready</div>
        <div>
            <label for="fileInput">Load Model:</label>
            <input type="file" id="fileInput" accept=".glb,.gltf" />
        </div>
        <div class="info">
            <strong>Controls:</strong><br/>
            Drag: Rotate<br/>
            Scroll: Zoom<br/>
            Or select a .glb/.gltf file
        </div>
    </div>

    <!-- Local Three.js via import map -->
    <script type="importmap">
    {
        "imports": {
            "three": "./node_modules/three/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';

        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const fileInput = document.getElementById('fileInput');

        let scene, camera, renderer, model, controls = { isDragging: false, previousMousePosition: { x: 0, y: 0 } };

        function setupScene() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Animation loop
            animate();

            // Event listeners
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel, false);
            fileInput.addEventListener('change', onFileSelect);
            canvas.addEventListener('dragover', e => e.preventDefault());
            canvas.addEventListener('drop', onFileDrop);
            window.addEventListener('resize', onWindowResize);

            statusDiv.textContent = 'âœ“ Three.js Loaded Successfully';
        }

        function animate() {
            requestAnimationFrame(animate);
            if (model) {
                model.rotation.y += 0.001;
            }
            renderer.render(scene, camera);
        }

        function loadFile(file) {
            if (!file.name.endsWith('.glb') && !file.name.endsWith('.gltf')) {
                statusDiv.textContent = 'âœ— Only .glb/.gltf files supported';
                statusDiv.classList.add('error');
                return;
            }

            statusDiv.textContent = 'â³ Loading...';
            statusDiv.classList.remove('error');

            const url = URL.createObjectURL(file);
            const loader = new GLTFLoader();

            loader.load(
                url,
                (gltf) => {
                    // Remove old model
                    if (model) scene.remove(model);

                    model = gltf.scene;
                    scene.add(model);

                    // Auto-fit camera
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    model.scale.multiplyScalar(scale);

                    camera.position.z = 5;

                    // Log animations to console
                    if (gltf.animations && gltf.animations.length > 0) {
                        console.log(`%cðŸŽ¬ ANIMATIONS FOUND (${gltf.animations.length}):`, 'color: #0f0; font-weight: bold; font-size: 14px;');
                        gltf.animations.forEach((clip, idx) => {
                            console.log(`  [${idx}] "${clip.name}" - Duration: ${clip.duration.toFixed(2)}s, Tracks: ${clip.tracks.length}`);
                        });
                    } else {
                        console.log('%câš ï¸  No animations found in this model', 'color: #ff0; font-weight: bold;');
                    }

                    statusDiv.textContent = `âœ“ Loaded: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`;
                    statusDiv.classList.remove('error');
                    URL.revokeObjectURL(url);
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(1);
                    statusDiv.textContent = `â³ Loading... ${percent}%`;
                },
                (error) => {
                    console.error('Model load error:', error);
                    statusDiv.textContent = `âœ— Load Error: ${error.message}`;
                    statusDiv.classList.add('error');
                    URL.revokeObjectURL(url);
                }
            );
        }

        function onFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadFile(file);
        }

        function onFileDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) {
                fileInput.files = e.dataTransfer.files;
                loadFile(file);
            }
        }

        function onMouseDown(e) {
            controls.isDragging = true;
            controls.previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (controls.isDragging && model) {
                const deltaX = e.clientX - controls.previousMousePosition.x;
                const deltaY = e.clientY - controls.previousMousePosition.y;
                model.rotation.y += deltaX * 0.005;
                model.rotation.x += deltaY * 0.005;
                controls.previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() {
            controls.isDragging = false;
        }

        function onMouseWheel(e) {
            e.preventDefault();
            const zoomSpeed = 0.1;
            if (e.deltaY < 0) {
                camera.position.z -= zoomSpeed;
            } else {
                camera.position.z += zoomSpeed;
            }
            camera.position.z = Math.max(1, Math.min(20, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize
        try {
            setupScene();
            statusDiv.textContent = 'âœ“ Ready - Load a .glb/.gltf model';
        } catch (error) {
            console.error('Setup error:', error);
            statusDiv.textContent = `âœ— Setup failed: ${error.message}`;
            statusDiv.classList.add('error');
        }
    </script>
</body>
</html>
