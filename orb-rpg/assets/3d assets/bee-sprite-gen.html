<!DOCTYPE html>
<html>
<head>
  <title>Bee Sprite Sheet Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #222;
      color: #fff;
      font-family: monospace;
    }
    #canvas {
      border: 2px solid #0f0;
      background: transparent;
      image-rendering: pixelated;
    }
    .controls {
      margin: 20px 0;
      padding: 20px;
      background: #333;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #0a0;
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover { background: #0c0; }
    button:disabled { background: #555; cursor: not-allowed; }
    #output {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .frame {
      border: 1px solid #666;
      background: #444;
    }
    #log {
      margin-top: 20px;
      padding: 10px;
      background: #111;
      border: 1px solid #444;
      max-height: 200px;
      overflow-y: auto;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>Bee Sprite Sheet Generator</h1>
  
  <div class="controls">
    <div>
      <label>Animation:</label>
      <select id="animSelect">
        <option value="hover">Hover</option>
        <option value="idle">Idle</option>
        <option value="take_off_and_land">Take Off and Land</option>
      </select>
    </div>
    
    <div style="margin-top: 10px;">
      <label>Frame Size:</label>
      <input type="number" id="frameSize" value="128" min="32" max="512" step="32">px
    </div>
    
    <div style="margin-top: 10px;">
      <label>FPS:</label>
      <input type="number" id="fps" value="15" min="5" max="60">
      <span style="margin-left: 20px;">Camera Angle:</span>
      <input type="number" id="cameraAngle" value="45" min="0" max="90" step="5">Â°
    </div>
    
    <div style="margin-top: 10px;">
      <label>Directions:</label>
      <input type="number" id="directions" value="8" min="1" max="16">
    </div>
    
    <div style="margin-top: 15px;">
      <button id="loadBtn">Load Model</button>
      <button id="captureBtn" disabled>Capture Frames</button>
      <button id="downloadBtn" disabled>Download Sprite Sheet</button>
      <button id="downloadJsonBtn" disabled>Download Animation Data</button>
    </div>
    
    <div style="margin-top: 10px;">
      <span id="status">Ready</span>
    </div>
  </div>
  
  <canvas id="canvas" width="128" height="128"></canvas>
  
  <div id="output"></div>
  
  <div id="log"></div>
  
  <script>
    // Check if libraries loaded
    console.log('THREE loaded?', typeof THREE !== 'undefined');
    console.log('GLTFLoader loaded?', typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined');
    
    // THREE is loaded globally from CDN
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const log = document.getElementById('log');
    
    let scene, camera, renderer, model, mixer, animations, clock;
    let capturedFrames = [];
    
    function addLog(msg) {
      const time = new Date().toLocaleTimeString();
      log.innerHTML += `[${time}] ${msg}<br>`;
      log.scrollTop = log.scrollHeight;
    }
    
    document.getElementById('loadBtn').onclick = async () => {
      try {
        addLog('Loading bee model...');
        document.getElementById('status').textContent = 'Loading...';
        
        // Setup Three.js
        const frameSize = parseInt(document.getElementById('frameSize').value);
        canvas.width = frameSize;
        canvas.height = frameSize;
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = frameSize;
        tempCanvas.height = frameSize;
        
        scene = new THREE.Scene();
        scene.background = null;
        
        const angle = parseInt(document.getElementById('cameraAngle').value);
        const angleRad = (angle * Math.PI) / 180;
        const dist = 3;
        
        camera = new THREE.PerspectiveCamera(50, 1, 0.01, 1000);
        camera.position.set(0, Math.sin(angleRad) * dist, Math.cos(angleRad) * dist);
        camera.lookAt(0, 0, 0);
        
        renderer = new THREE.WebGLRenderer({ canvas: tempCanvas, alpha: true, antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(frameSize, frameSize);
        renderer.setPixelRatio(1);
        
        // Lighting
        const amb = new THREE.AmbientLight(0xffffff, 1.2);
        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(5, 8, 5);
        const dir2 = new THREE.DirectionalLight(0xccffff, 0.5);
        dir2.position.set(-5, 3, -5);
        scene.add(amb, dir, dir2);
        
        // Load model
        const loader = new THREE.GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load('./Flying bee.glb', 
            (gltf) => {
              addLog('Model loaded successfully');
              resolve(gltf);
            },
            (progress) => {
              const percent = (progress.loaded / progress.total * 100).toFixed(1);
              addLog(`Loading... ${percent}%`);
            },
            (error) => {
              addLog('Load error: ' + error.message);
              reject(error);
            }
          );
        });
        
        model = gltf.scene;
        animations = gltf.animations;
        
        addLog(`Loaded model with ${animations.length} animations`);
        animations.forEach((anim, i) => {
          addLog(`  ${i}: ${anim.name} (${anim.duration.toFixed(2)}s)`);
        });
        
        // Center and scale
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.5 / maxDim;
        model.scale.setScalar(scale);
        
        // Fix materials
        model.traverse(node => {
          if(node.isMesh && node.material){
            node.material.side = THREE.DoubleSide;
          }
        });
        
        scene.add(model);
        
        // Setup animation
        mixer = new THREE.AnimationMixer(model);
        clock = new THREE.Clock();
        
        // Render preview
        renderer.render(scene, camera);
        ctx.clearRect(0, 0, frameSize, frameSize);
        ctx.drawImage(tempCanvas, 0, 0);
        
        document.getElementById('status').textContent = 'Model loaded';
        document.getElementById('captureBtn').disabled = false;
        addLog('Ready to capture frames');
        
      } catch(err) {
        addLog('ERROR: ' + err.message);
        document.getElementById('status').textContent = 'Error loading model';
      }
    };
    
    document.getElementById('captureBtn').onclick = async () => {
      try {
        const animName = document.getElementById('animSelect').value;
        const frameSize = parseInt(document.getElementById('frameSize').value);
        const fps = parseInt(document.getElementById('fps').value);
        const numDirections = parseInt(document.getElementById('directions').value);
        
        addLog(`Capturing ${animName} animation at ${fps}fps in ${numDirections} directions...`);
        document.getElementById('status').textContent = 'Capturing...';
        document.getElementById('captureBtn').disabled = true;
        
        capturedFrames = [];
        output.innerHTML = '';
        
        // Find animation
        const anim = animations.find(a => a.name === animName);
        if(!anim) {
          addLog('ERROR: Animation not found');
          return;
        }
        
        const duration = anim.duration;
        const frameCount = Math.ceil(duration * fps);
        const timeStep = duration / frameCount;
        
        addLog(`Duration: ${duration.toFixed(2)}s, Frames: ${frameCount}`);
        
        // For each direction
        for(let dir = 0; dir < numDirections; dir++) {
          const angle = (dir / numDirections) * Math.PI * 2;
          model.rotation.y = angle;
          
          // Reset animation
          mixer.stopAllAction();
          const action = mixer.clipAction(anim);
          action.reset();
          action.play();
          action.paused = true;
          
          // Capture frames
          for(let frame = 0; frame < frameCount; frame++) {
            const time = frame * timeStep;
            
            // Update animation
            mixer.setTime(time);
            
            // Render
            renderer.render(scene, camera);
            
            // Capture to canvas
            const img = new Image();
            img.src = renderer.domElement.toDataURL('image/png');
            await new Promise(resolve => img.onload = resolve);
            
            capturedFrames.push({
              direction: dir,
              frame: frame,
              image: img.src
            });
            
            // Show preview
            const imgEl = document.createElement('img');
            imgEl.src = img.src;
            imgEl.width = 64;
            imgEl.height = 64;
            imgEl.title = `Dir ${dir}, Frame ${frame}`;
            imgEl.className = 'frame';
            output.appendChild(imgEl);
            
            document.getElementById('status').textContent = `Capturing dir ${dir+1}/${numDirections}, frame ${frame+1}/${frameCount}`;
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
        
        addLog(`Captured ${capturedFrames.length} frames`);
        document.getElementById('status').textContent = 'Capture complete';
        document.getElementById('downloadBtn').disabled = false;
        document.getElementById('downloadJsonBtn').disabled = false;
        document.getElementById('captureBtn').disabled = false;
        
      } catch(err) {
        addLog('ERROR: ' + err.message);
        document.getElementById('status').textContent = 'Error capturing';
        document.getElementById('captureBtn').disabled = false;
      }
    };
    
    document.getElementById('downloadBtn').onclick = async () => {
      try {
        const frameSize = parseInt(document.getElementById('frameSize').value);
        const numDirections = parseInt(document.getElementById('directions').value);
        const framesPerDir = capturedFrames.length / numDirections;
        
        // Create sprite sheet
        const sheetCanvas = document.createElement('canvas');
        sheetCanvas.width = frameSize * framesPerDir;
        sheetCanvas.height = frameSize * numDirections;
        const sheetCtx = sheetCanvas.getContext('2d');
        
        addLog('Creating sprite sheet...');
        
        for(let i = 0; i < capturedFrames.length; i++) {
          const f = capturedFrames[i];
          const x = (i % framesPerDir) * frameSize;
          const y = f.direction * frameSize;
          
          const img = new Image();
          img.src = f.image;
          await new Promise(resolve => img.onload = resolve);
          
          sheetCtx.drawImage(img, x, y, frameSize, frameSize);
        }
        
        // Download
        const animName = document.getElementById('animSelect').value;
        sheetCanvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `bee-${animName}-${numDirections}dir.png`;
          a.click();
          addLog(`Downloaded sprite sheet: ${a.download}`);
        });
        
      } catch(err) {
        addLog('ERROR: ' + err.message);
      }
    };
    
    document.getElementById('downloadJsonBtn').onclick = () => {
      const frameSize = parseInt(document.getElementById('frameSize').value);
      const fps = parseInt(document.getElementById('fps').value);
      const numDirections = parseInt(document.getElementById('directions').value);
      const framesPerDir = capturedFrames.length / numDirections;
      const animName = document.getElementById('animSelect').value;
      
      const data = {
        animation: animName,
        frameSize: frameSize,
        fps: fps,
        directions: numDirections,
        framesPerDirection: framesPerDir,
        totalFrames: capturedFrames.length,
        spriteSheet: `bee-${animName}-${numDirections}dir.png`
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bee-${animName}-${numDirections}dir.json`;
      a.click();
      addLog(`Downloaded animation data: ${a.download}`);
    };
    
    addLog('Sprite sheet generator ready');
  </script>
</body>
</html>
